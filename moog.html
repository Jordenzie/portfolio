<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Mini Synth</title>
<style>
  body { margin: 0; background:#111; color:#ddd; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
  .bar { display:flex; gap:10px; padding:12px; align-items:center; background:#0b0b0b; border-bottom:1px solid #222; }
  button { padding:10px 12px; border-radius:10px; border:1px solid #333; background:#141414; color:#ddd; cursor:pointer; }
  button:active { transform: translateY(1px); }
  .hint { opacity:.85; font-size:12px; }
  canvas {
    display:block;
    width: 100vw;
    height: calc(100vh - 56px);
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    background:#101010;
  }
</style>
</head>
<body>
  <div class="bar">
    <button id="start">Start Audio</button>
    <button id="panic">Panic</button>
    <div class="hint">Play: A W S E D F T G Y H U J K — or click keys</div>
  </div>
  <canvas id="c"></canvas>

<script>
/* ========= AudioWorklet (same synth core as before, trimmed UI) ========= */
const WORKLET_CODE = `
class ADSR {
  constructor(sr){ this.sr=sr; this.a=.01; this.d=.15; this.s=.7; this.r=.2; this.state=0; this.y=0; this.gate=0; }
  set(a,d,s,r){ this.a=a; this.d=d; this.s=s; this.r=r; }
  noteOn(legato=false){ this.gate=1; if(!legato) this.state=1; else if(this.state===0) this.state=1; }
  noteOff(){ this.gate=0; if(this.state!==0) this.state=4; }
  tick(){
    const eps=1e-9;
    if(this.state===0) return 0;
    if(this.state===1){ const k=Math.exp(-1/(Math.max(this.a,eps)*this.sr)); this.y=1+(this.y-1)*k; if(this.y>.999){this.y=1; this.state=2;} }
    else if(this.state===2){ const t=this.s; const k=Math.exp(-1/(Math.max(this.d,eps)*this.sr)); this.y=t+(this.y-t)*k; if(Math.abs(this.y-t)<1e-4){this.y=t; this.state=3;} }
    else if(this.state===3){ this.y=this.s; if(!this.gate) this.state=4; }
    else if(this.state===4){ const k=Math.exp(-1/(Math.max(this.r,eps)*this.sr)); this.y=(this.y)*k; if(this.y<1e-4){this.y=0; this.state=0;} }
    return this.y;
  }
}
function xorshift32(s){ s ^= s<<13; s ^= s>>>17; s ^= s<<5; return s|0; }
function polyBlep(t, dt){
  if (t < dt) { t/=dt; return t+t - t*t - 1; }
  if (t > 1-dt) { t=(t-1)/dt; return t*t + t + t + 1; }
  return 0;
}
class Osc {
  constructor(sr){ this.sr=sr; this.phase=0; this.freq=110; this.wave=0; this.pw=0.5; this.lastParab=0; this._tri=0; }
  set(freq,wave,pw){ this.freq=freq; this.wave=wave; this.pw=pw; }
  tick(){
    const dt=this.freq/this.sr;
    this.phase+=dt; if(this.phase>=1) this.phase-=1;

    if(this.wave===0){ // DPW saw
      const x=this.phase*2-1;
      const parab=x*x;
      let y=(parab-this.lastParab)*(this.sr/(2*this.freq+1e-9));
      this.lastParab=parab;
      y=Math.max(-1,Math.min(1,y*0.9));
      return y;
    }
    if(this.wave===1){ // BLEP pulse
      let t=this.phase;
      let y=(t<this.pw)?1:-1;
      y+=polyBlep(t,dt);
      let t2=t-this.pw; if(t2<0) t2+=1;
      y-=polyBlep(t2,dt);
      return y*0.8;
    }
    // triangle from blep square
    let t=this.phase;
    let sq=(t<0.5)?1:-1;
    sq+=polyBlep(t,dt);
    sq-=polyBlep((t+0.5)%1,dt);
    this._tri=(this._tri + sq*dt)*0.9995;
    return Math.max(-1,Math.min(1,this._tri*2.2));
  }
}
class Ladderish {
  constructor(sr){ this.sr=sr; this.z1=0; this.z2=0; this.z3=0; this.z4=0; this.cut=1200; this.res=.2; this.drive=.2; }
  set(cut,res,drive){ this.cut=cut; this.res=res; this.drive=drive; }
  tick(x){
    if(this.drive>0) x=Math.tanh((1+this.drive*6)*x);
    const fc=Math.max(10,Math.min(this.cut,this.sr*0.45));
    const g=Math.tan(Math.PI*fc/this.sr);
    const G=g/(1+g);
    const fb=this.res*4.0;
    let u=x - fb*Math.tanh(this.z4*0.8);

    const v1=(u-this.z1)*G; const y1=v1+this.z1; this.z1=y1+v1;
    const v2=(y1-this.z2)*G; const y2=v2+this.z2; this.z2=y2+v2;
    const v3=(y2-this.z3)*G; const y3=v3+this.z3; this.z3=y3+v3;
    const v4=(y3-this.z4)*G; const y4=v4+this.z4; this.z4=y4+v4;

    return Math.tanh(y4*1.1);
  }
}
class MiniishProcessor extends AudioWorkletProcessor {
  static get parameterDescriptors(){
    const p=(n,d,min,max)=>({name:n,defaultValue:d,minValue:min,maxValue:max,automationRate:"k-rate"});
    return [
      p("master",0.35,0,1),
      p("wave",0,0,2), p("pw",0.5,0.05,0.95),
      p("osc1",0.8,0,1), p("osc2",0.35,0,1), p("osc3",0.2,0,1),
      p("det2",0,-12,12), p("det3",0,-24,24),
      p("drift",0.02,0,0.2),
      p("mixDrive",0.25,0,1),
      p("cut",1200,30,12000), p("res",0.25,0,1), p("fEnvAmt",2400,0,8000), p("fDrive",0.2,0,1),
      p("aA",0.005,0.001,3), p("aD",0.12,0.001,3), p("aS",0.75,0,1), p("aR",0.18,0.001,5),
      p("fA",0.005,0.001,3), p("fD",0.18,0.001,3), p("fS",0.0,0,1), p("fR",0.2,0.001,5),
      p("glide",0.03,0,0.4), p("legato",1,0,1),
      p("gate",0,0,1), p("freq",110,20,2000),
    ];
  }
  constructor(){
    super();
    this.sr=sampleRate;
    this.oscA=new Osc(this.sr); this.oscB=new Osc(this.sr); this.oscC=new Osc(this.sr);
    this.filt=new Ladderish(this.sr);
    this.ampEnv=new ADSR(this.sr); this.fltEnv=new ADSR(this.sr);
    this.curFreq=110; this.targetFreq=110;
    this._gate=0; this._rng=123456789; this._drift2=0; this._drift3=0;
  }
  process(inputs, outputs, p){
    const out=outputs[0];
    const L=out[0]; const R=out[1] ?? out[0];
    const k=(n)=>p[n][0];

    const master=k("master");
    const wave=k("wave")|0, pw=k("pw");
    const osc1=k("osc1"), osc2=k("osc2"), osc3=k("osc3");
    const det2=k("det2"), det3=k("det3"), drift=k("drift");
    const mixDrive=k("mixDrive");
    const cut=k("cut"), res=k("res"), fEnvAmt=k("fEnvAmt"), fDrive=k("fDrive");
    const glide=k("glide"), legato=k("legato")>0.5;
    const gate=k("gate")>0.5?1:0, freq=k("freq");

    this.ampEnv.set(k("aA"),k("aD"),k("aS"),k("aR"));
    this.fltEnv.set(k("fA"),k("fD"),k("fS"),k("fR"));

    if(gate && !this._gate){ this.ampEnv.noteOn(legato); this.fltEnv.noteOn(legato); }
    else if(!gate && this._gate){ this.ampEnv.noteOff(); this.fltEnv.noteOff(); }
    this._gate=gate;
    this.targetFreq=freq;

    this.filt.set(cut,res,fDrive);

    for(let i=0;i<L.length;i++){
      if(glide<=0.0001) this.curFreq=this.targetFreq;
      else { const alpha=Math.exp(-1/(glide*this.sr)); this.curFreq=this.targetFreq+(this.curFreq-this.targetFreq)*alpha; }

      // drift random walk
      this._rng=xorshift32(this._rng); const n1=(this._rng/2147483648)*2-1;
      this._rng=xorshift32(this._rng); const n2=(this._rng/2147483648)*2-1;
      this._drift2=(this._drift2*0.99995)+n1*drift*0.00005;
      this._drift3=(this._drift3*0.99995)+n2*drift*0.00005;

      const f1=this.curFreq;
      const f2=this.curFreq*Math.pow(2,det2/12)*(1+this._drift2);
      const f3=this.curFreq*Math.pow(2,det3/12)*(1+this._drift3);

      this.oscA.set(f1,wave,pw); this.oscB.set(f2,wave,pw); this.oscC.set(f3,wave,pw);

      let x = this.oscA.tick()*osc1 + this.oscB.tick()*osc2 + this.oscC.tick()*osc3;

      if(mixDrive>0) x=Math.tanh((1+mixDrive*8)*x);

      const aE=this.ampEnv.tick();
      const fE=this.fltEnv.tick();
      this.filt.cut = cut + fE*fEnvAmt;

      let y=this.filt.tick(x);
      y *= aE;
      y = Math.tanh(y*1.2);

      const o=y*master;
      L[i]=o; R[i]=o;
    }
    return true;
  }
}
registerProcessor("miniish", MiniishProcessor);
`;

let ctx, node, params, started=false;

async function startAudio(){
  if(started) return;
  started=true;
  ctx=new (window.AudioContext||window.webkitAudioContext)();
  const url=URL.createObjectURL(new Blob([WORKLET_CODE], {type:"application/javascript"}));
  await ctx.audioWorklet.addModule(url);
  node=new AudioWorkletNode(ctx, "miniish", {numberOfOutputs:1, outputChannelCount:[2]});
  node.connect(ctx.destination);
  params = node.parameters;
  // defaults
  params.get("gate").setValueAtTime(0, ctx.currentTime);
  params.get("freq").setValueAtTime(440, ctx.currentTime);
  await ctx.resume();
}
function panic(){
  if(!ctx||!params) return;
  held.clear();
  params.get("gate").setValueAtTime(0, ctx.currentTime);
}

/* ========= Pixel canvas scene ========= */
const canvas = document.getElementById("c");
const g = canvas.getContext("2d");

function resize(){
  // render at low internal resolution for pixel look
  const scale = 2; // UI scale factor
  const w = Math.floor(window.innerWidth / scale);
  const h = Math.floor((window.innerHeight - 56) / scale);
  canvas.width = Math.max(320, w);
  canvas.height = Math.max(200, h);
}
window.addEventListener("resize", resize);
resize();

// Key layout: 13 keys (C..C)
const keyOrder = ["a","w","s","e","d","f","t","g","y","h","u","j","k"];
const baseMidi = 60; // C4
const held = new Set();

function midiToHz(m){ return 440 * Math.pow(2, (m-69)/12); }

const keys = [];
function buildKeys(){
  keys.length = 0;
  // keyboard area
  const pad = 16;
  const panelW = canvas.width - pad*2;
  const panelH = 84;
  const panelX = pad;
  const panelY = canvas.height - panelH - pad;

  // white-key baseline positions: 8 whites in an octave + top C = 8? For 13 semis, we draw "piano-ish" but simple.
  // We'll draw 13 equal tiles for “gamey” pixel keys; black keys are just “accent” overlays.
  const tileW = Math.floor(panelW / 13);
  const tileH = 56;
  const x0 = panelX + Math.floor((panelW - tileW*13)/2);
  const y0 = panelY + 18;

  for(let i=0;i<13;i++){
    keys.push({
      i,
      key: keyOrder[i],
      midi: baseMidi + i,
      x: x0 + i*tileW,
      y: y0,
      w: tileW-2,
      h: tileH,
      down: false
    });
  }
  return {panelX,panelY,panelW,panelH};
}
let panel = buildKeys();

function setGate(on){
  if(!params) return;
  params.get("gate").setValueAtTime(on?1:0, ctx.currentTime);
}
function setFreq(hz){
  if(!params) return;
  params.get("freq").setValueAtTime(hz, ctx.currentTime);
}

function playKeyIndex(i, isDown){
  const k = keys[i];
  if(!k) return;

  k.down = isDown;

  if(isDown){
    setFreq(midiToHz(k.midi));
    setGate(true);
  } else {
    // if any still down, keep playing highest (or last) — simple: highest midi held
    const still = keys.filter(x=>x.down);
    if(still.length){
      still.sort((a,b)=>b.midi-a.midi);
      setFreq(midiToHz(still[0].midi));
      setGate(true);
    } else {
      setGate(false);
    }
  }
}

function keyDown(letter){
  const idx = keyOrder.indexOf(letter);
  if(idx < 0) return;
  held.add(letter);
  playKeyIndex(idx, true);
}
function keyUp(letter){
  const idx = keyOrder.indexOf(letter);
  if(idx < 0) return;
  held.delete(letter);
  playKeyIndex(idx, false);
}

window.addEventListener("keydown", (e)=>{
  if(!started) return;
  const k = e.key.toLowerCase();
  if(!keyOrder.includes(k) || e.repeat) return;
  keyDown(k);
});
window.addEventListener("keyup", (e)=>{
  if(!started) return;
  const k = e.key.toLowerCase();
  if(!keyOrder.includes(k)) return;
  keyUp(k);
});

/* Mouse / touch hit-test */
function getPos(evt){
  const r = canvas.getBoundingClientRect();
  const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
  const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
  // convert to canvas internal coords
  const x = (clientX - r.left) * (canvas.width / r.width);
  const y = (clientY - r.top) * (canvas.height / r.height);
  return {x,y};
}
let pointerDown = false;
let activeKey = -1;

function hitKey(x,y){
  for(let i=0;i<keys.length;i++){
    const k=keys[i];
    if(x>=k.x && x<=k.x+k.w && y>=k.y && y<=k.y+k.h) return i;
  }
  return -1;
}

canvas.addEventListener("mousedown", (e)=>{
  if(!started) return;
  pointerDown = true;
  const {x,y} = getPos(e);
  const i = hitKey(x,y);
  if(i>=0){ activeKey=i; playKeyIndex(i,true); }
});
window.addEventListener("mouseup", ()=>{
  if(!started) return;
  if(pointerDown){
    pointerDown=false;
    if(activeKey>=0){ playKeyIndex(activeKey,false); activeKey=-1; }
  }
});
canvas.addEventListener("mousemove", (e)=>{
  if(!started || !pointerDown) return;
  const {x,y} = getPos(e);
  const i = hitKey(x,y);
  if(i !== activeKey){
    if(activeKey>=0) playKeyIndex(activeKey,false);
    activeKey = i;
    if(activeKey>=0) playKeyIndex(activeKey,true);
  }
});

// Touch
canvas.addEventListener("touchstart", (e)=>{
  if(!started) return;
  e.preventDefault();
  pointerDown=true;
  const {x,y} = getPos(e);
  const i = hitKey(x,y);
  if(i>=0){ activeKey=i; playKeyIndex(i,true); }
},{passive:false});

canvas.addEventListener("touchmove", (e)=>{
  if(!started || !pointerDown) return;
  e.preventDefault();
  const {x,y} = getPos(e);
  const i = hitKey(x,y);
  if(i !== activeKey){
    if(activeKey>=0) playKeyIndex(activeKey,false);
    activeKey = i;
    if(activeKey>=0) playKeyIndex(activeKey,true);
  }
},{passive:false});

canvas.addEventListener("touchend", (e)=>{
  if(!started) return;
  e.preventDefault();
  pointerDown=false;
  if(activeKey>=0){ playKeyIndex(activeKey,false); activeKey=-1; }
},{passive:false});

/* ========= Pixel drawing ========= */
function pxRect(x,y,w,h,fill,stroke){
  g.fillStyle = fill;
  g.fillRect(x,y,w,h);
  if(stroke){
    g.strokeStyle = stroke;
    g.strokeRect(x+0.5,y+0.5,w-1,h-1);
  }
}
function pxText(text,x,y,color="#ddd"){
  g.fillStyle=color;
  g.fillText(text, x, y);
}
function draw(){
  // background
  g.imageSmoothingEnabled = false;
  g.clearRect(0,0,canvas.width,canvas.height);

  // pixel font-ish
  g.font = "10px ui-monospace, SFMono-Regular, Menlo, monospace";

  // top-down “room”
  pxRect(0,0,canvas.width,canvas.height,"#0f0f12");
  pxRect(10,10,canvas.width-20,canvas.height-20,"#121218","#20202a");

  // synth table
  pxRect(24,24,canvas.width-48,canvas.height-140,"#15151c","#2a2a36");
  pxText("PIXEL SYNTH DESK", 34, 40, "#bdbdff");

  // panel
  panel = buildKeys();
  const {panelX,panelY,panelW,panelH} = panel;
  pxRect(panelX,panelY,panelW,panelH,"#121217","#2a2a2a");

  // keys
  for(const k of keys){
    const fill = k.down ? "#ffe27a" : "#d9d9d9";
    const stroke = k.down ? "#7a5d00" : "#777";
    pxRect(k.x,k.y,k.w,k.h,fill,stroke);

    // little label
    pxText(k.key.toUpperCase(), k.x + 4, k.y + 12, k.down ? "#3a2a00" : "#222");
  }

  // status text
  pxText(started ? "AUDIO: ON" : "AUDIO: OFF", 34, panelY - 10, started ? "#9cff9c" : "#ff9c9c");

  requestAnimationFrame(draw);
}
draw();

/* buttons */
document.getElementById("start").addEventListener("click", startAudio);
document.getElementById("panic").addEventListener("click", panic);
</script>
</body>
</html>
